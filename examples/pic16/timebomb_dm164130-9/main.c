/*.$file${.::main.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: TimeBomb.qm
* File:  ${.::main.c}
*
* This code has been generated by QM 5.1.1 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::main.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/* TimeBomb/Button with QP/M framework development. */
//    2/5/2022;ARS
/* ReadySet is needed to make the scheduler run the highest priority task first
   when it has an event waiting.  Its implementation is NECESSARY. */
//#define QF_MAX_TICK_RATE        1
//#define QF_TIMEEVT_CTR_SIZE     2
//#undef QF_TIMEEVT_PERIODIC
//#undef QF_TIMEEVT_USAGE             // Sleep mode is not used
// +Hsm/Q_PARAM_SIZE=2/X       : MPLAB Usage: Program: 4244/8192 (51.8%), Data: 157/1024 (15.3%) */
// +Hsm/Q_PARAM_SIZE=0/X       : MPLAB Usage: Program: 4003/8192 (48.9%), Data: 116/1024 (11.3%) */

//    2/9/2022;ARS
/* Moved the message event inside the State machine structure to rendezvous with QM/QPN for closely. */
//#define QF_MAX_TICK_RATE        1
//#define QF_TIMEEVT_CTR_SIZE     2
//#undef QF_TIMEEVT_PERIODIC
//#undef QF_TIMEEVT_USAGE             // Sleep mode is not used
// +Hsm/Q_PARAM_SIZE=2/X       : MPLAB Usage: Program: 4450/8192 (54.3%), Data: 174/1024 (17.0%) */
// +Hsm/Q_PARAM_SIZE=0/X       : MPLAB Usage: Program: 4309/8192 (52.6%), Data: 124/1024 (12.1%) */

//2/15/2022 11:47:30 AM;ARS- Implemented changes below:
//* Move the init, dispatch, & postISR to reference Vtable function pointers and condense.
//* Move the post to reference Vtable function pointers & consolidate the results:
//* Modify/Test TimeBomb to post a message outside the ISR
//* Modify/Test TimeBomb to test QActive_disarmX
//* "Backfill" the remaining post & param != 0 functions {QACTIVE_POST_X_ISR(P=0), QACTIVE_POST_X(P=0), QACTIVE_POST_X_ISR(P!=0), QACTIVE_POST_X(P!=0)}
//2/15/2022 1:50:53 PM;ARS- * Test QF_MARGIN: tested that QACTIVE_POST_X with & without PAR returned true & false with appropriate margin values.
//2/15/2022 2:06:24 PM;ARS- * Tested QACTIVE_POST_X_ISR to throw an assertion failure using QF_NO_MARGIN by stuffing the queue with BUTTON_PRESSED_SIG.
//2/15/2022 4:26:34 PM;ARS- * Test Event timer arm/disarm: Pass
//2/15/2022 4:26:48 PM;ARS- * Test QF_TIMEEVT_PERIODIC: Pass
//2/15/2022 4:36:09 PM;ARS- * Test QF_TIMEEVT_USAGE:Pass, appeared to work for one time under test.
/* 2/16/2022 4:53:12 PM;ARS- * Investigate bool return for post/postISR macros
for VTable.  Made a global variable, QACTIVE_POST_res_, to capture the
QACTIVE_POST results allowing them to be tested for success or failure.  This
is needed when MARGIN values are actually used. */
//c90:
//#define QF_MAX_TICK_RATE    1
//#define QF_TIMEEVT_CTR_SIZE 2
//#undef QF_TIMEEVT_PERIODIC
//#undef QF_TIMEEVT_USAGE
//#define QF_MARGIN           0   // 0xFF- QF_NO_MARGIN, 0- no margin function calls
//#undef USE_FULL_TEST            // undef- no extra test code
// +QPN/Q_PARAM_SIZE=0/Vtable  : MPLAB Usage: Program: 4445/8192 (54.3%), Data: 143/1024 (14.0%)
// +QPN/Q_PARAM_SIZE=0/NoVtable: MPLAB Usage: Program: 4392/8192 (53.6%), Data: 131/1024 (12.8%)
// +Hsm/Q_PARAM_SIZE=0/X       : MPLAB Usage: Program: 4239/8192 (51.7%), Data: 126/1024 (12.3%)
// +QPN/Q_PARAM_SIZE=2/Vtable  : MPLAB Usage: Program: 4610/8192 (56.3%), Data: 169/1024 (16.5%)
// +QPN/Q_PARAM_SIZE=2/NoVtable: MPLAB Usage: Program: 4657/8192 (56.8%), Data: 157/1024 (15.3%)
// +Hsm/Q_PARAM_SIZE=2/X       : MPLAB Usage: Program: 4275/8192 (52.2%), Data: 168/1024 (16.4%)
// +QPN/Q_PARAM_SIZE=4/Vtable  : MPLAB Usage: Program: 4703/8192 (57.4%), Data: 197/1024 (19.2%)
// +QPN/Q_PARAM_SIZE=4/NoVtable: MPLAB Usage: Program: 4618/8192 (56.4%), Data: 185/1024 (18.1%)
// +Hsm/Q_PARAM_SIZE=4/X       : MPLAB Usage: Program: 4314/8192 (52.7%), Data: 212/1024 (20.7%)
//c99:
//#define QF_MAX_TICK_RATE    1
//#define QF_TIMEEVT_CTR_SIZE 2
//#undef QF_TIMEEVT_PERIODIC
//#undef QF_TIMEEVT_USAGE
//#define QF_MARGIN           0   // 0xFF- QF_NO_MARGIN, 0- no margin function calls
//#undef USE_FULL_TEST            // undef- no extra test code
// +QPN/Q_PARAM_SIZE=0/Vtable  : MPLAB Usage: Program: 4554/8192 (55.7%), Data: 145/1024 (14.2%)
// +QPN/Q_PARAM_SIZE=0/NoVtable: MPLAB Usage: Program: 4554/8192 (55.6%), Data: 134/1024 (13.1%)
// +Hsm/Q_PARAM_SIZE=0/X       : MPLAB Usage: Program: 4290/8192 (52.4%), Data: 128/1024 (12.5%)
// +QPN/Q_PARAM_SIZE=2/Vtable  : MPLAB Usage: Program: 4720/8192 (57.6%), Data: 171/1024 (16.7%)
// +QPN/Q_PARAM_SIZE=2/NoVtable: MPLAB Usage: Program: 4533/8192 (55.3%), Data: 159/1024 (15.5%)
// +Hsm/Q_PARAM_SIZE=2/X       : MPLAB Usage: Program: 4340/8192 (53.0%), Data: 170/1024 (16.6%)
// +QPN/Q_PARAM_SIZE=4/Vtable  : MPLAB Usage: Program: 4752/8192 (58.0%), Data: 199/1024 (19.4%)
// +QPN/Q_PARAM_SIZE=4/NoVtable: MPLAB Usage: Program: 4545/8192 (55.5%), Data: 187/1024 (18.3%)
// +Hsm/Q_PARAM_SIZE=4/X       : MPLAB Usage: Program: 4424/8192 (54.0%), Data: 214/1024 (20.9%)

#include "bsp.h"
#include "qfn_port.h"
#include "qassert.h"

#warning ----------------   Build Configuration   ----------------
#if   (defined XPRJ_Hsm)
    #warning Hsm/
#elif (defined XPRJ_QPN)
    #warning QPN/
#endif  //  #if   (defined XPRJ_Hsm)

#if (defined NO_QActiveVtable)
    #warning NoVTable/
#else
    #warning VTable  /
#endif  //  #if (defined NO_QActiveVtable)

#if   (Q_PARAM_SIZE == 0)
    #warning PARAM_SIZE=0:
#elif (Q_PARAM_SIZE == 2)
    #warning PARAM_SIZE=2:
#elif (Q_PARAM_SIZE == 4)
    #warning PARAM_SIZE=4:
#else
    #warning PARAM_SIZE=ERROR:
#endif  //  #if   (Q_PARAM_SIZE == 0)
#warning ----------------   Build Configuration   ----------------


/* Active objects... */
extern QActive *AO_TimeBomb;

Q_DEFINE_THIS_MODULE("main_Hsm") /* this module name for Q_ASSERT() */

/* The TimeBomb AO =======================================================*/
/*.$declare${AOs::TimeBomb} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::TimeBomb} ........................................................*/
typedef struct TimeBomb {
/* protected: */
    QActive super;

/* public: */

#if (QF_MAX_TICK_RATE == 0)
    QTimer te;
#endif /*  (QF_MAX_TICK_RATE == 0) */

    uint32_t blink_ctr;
} TimeBomb;

/* public: */
static void TimeBomb_ctor(void * me2);

/* protected: */
static QState TimeBomb_initial(void * me2);
static QState TimeBomb_armed(void * me2);
static QState TimeBomb_blink(void * me2);
static QState TimeBomb_pause(void * me2);
static QState TimeBomb_boom(void * me2);
static QState TimeBomb_wait4button(void * me2);
static QState TimeBomb_defuse(void * me2);
/*.$enddecl${AOs::TimeBomb} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpn version 6.9.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::TimeBomb} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::TimeBomb} ........................................................*/
/*.${AOs::TimeBomb::ctor} ..................................................*/
static void TimeBomb_ctor(void * me2) {
    TimeBomb *me = (TimeBomb *)me2;
    QActive_ctor(&(me->super), Q_STATE_CAST(&TimeBomb_initial));
    //QTimeEvt_ctorX(&me->te, &me->super, TIMEOUT_SIG, 0U);
}

/*.${AOs::TimeBomb::SM} ....................................................*/
static QState TimeBomb_initial(void * me2) {
    TimeBomb *me = (TimeBomb *)me2;
    /*.${AOs::TimeBomb::SM::initial} */
    return Q_TRAN(&TimeBomb_wait4button);
}
/*.${AOs::TimeBomb::SM::armed} .............................................*/
static QState TimeBomb_armed(void * me2) {
    TimeBomb *me = (TimeBomb *)me2;
    QState status_;
    switch (Q_SIG(me)) {
        /*.${AOs::TimeBomb::SM::armed} */
        case Q_EXIT_SIG: {
            BSP_ledRedOff();
            BSP_ledGreenOff();
            BSP_ledBlueOff();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::TimeBomb::SM::armed::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&TimeBomb_wait4button);
            break;
        }
        /*.${AOs::TimeBomb::SM::armed::BUTTON2_PRESSED} */
        case BUTTON2_PRESSED_SIG: {
            status_ = Q_TRAN(&TimeBomb_defuse);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::TimeBomb::SM::armed::blink} ......................................*/
static QState TimeBomb_blink(void * me2) {
    TimeBomb *me = (TimeBomb *)me2;
    QState status_;
    switch (Q_SIG(me)) {
        /*.${AOs::TimeBomb::SM::armed::blink} */
        case Q_ENTRY_SIG: {
            BSP_ledRedOn();
            #if (QF_MAX_TICK_RATE == 0)
                me->te.nTicks = BSP_TICKS_PER_SEC/2;    // This is the arm for TIMEOUT_SIG
            #else
                #ifndef QF_TIMEEVT_PERIODIC
                    QActive_armX(&(me->super), 0U, BSP_TICKS_PER_SEC/2);    // This is the arm for Q_TIMEOUT_SIG.
                #else
                    QActive_armX(&(me->super), 0U, BSP_TICKS_PER_SEC/2, BSP_TICKS_PER_SEC/2);
                #endif  //  #ifndef QF_TIMEEVT_PERIODIC
            #endif    //    #if (QF_MAX_TICK_RATE == 0)
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::TimeBomb::SM::armed::blink} */
        case Q_EXIT_SIG: {
            BSP_ledRedOff();
            status_ = Q_HANDLED();
            break;
        }

#if (QF_MAX_TICK_RATE != 0)
        /*.${AOs::TimeBomb::SM::armed::blink::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&TimeBomb_pause);
            break;
        }
#endif /*  (QF_MAX_TICK_RATE != 0) */

#if (QF_MAX_TICK_RATE == 0)
        /*.${AOs::TimeBomb::SM::armed::blink::TIMEOUT} */
        case TIMEOUT_SIG: {
            /*.${AOs::TimeBomb::SM::armed::blink::TIMEOUT::[te.nTicks>0]} */
            if (me->te.nTicks > 0) {
                --(me->te.nTicks);
                /*.${AOs::TimeBomb::SM::armed::blink::TIMEOUT::[te.nTicks>0]::[te.nTicks==0]} */
                if (me->te.nTicks == 0) {
                    status_ = Q_TRAN(&TimeBomb_pause);
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
#endif /*  (QF_MAX_TICK_RATE == 0) */

        default: {
            status_ = Q_SUPER(&TimeBomb_armed);
            break;
        }
    }
    return status_;
}
/*.${AOs::TimeBomb::SM::armed::pause} ......................................*/
static QState TimeBomb_pause(void * me2) {
    TimeBomb *me = (TimeBomb *)me2;
    QState status_;
    switch (Q_SIG(me)) {
        /*.${AOs::TimeBomb::SM::armed::pause} */
        case Q_ENTRY_SIG: {
            #if (QF_MAX_TICK_RATE == 0)
                me->te.nTicks = BSP_TICKS_PER_SEC/2;    // This is the arm for TIMEOUT_SIG
            #else
                #ifndef QF_TIMEEVT_PERIODIC
                    QActive_armX(&(me->super), 0U, BSP_TICKS_PER_SEC/2);    // This is the arm for Q_TIMEOUT_SIG.
                #else
                    QActive_armX(&(me->super), 0U, BSP_TICKS_PER_SEC/2, BSP_TICKS_PER_SEC/2);    // This is the arm for Q_TIMEOUT_SIG.
                #endif  //  #ifndef QF_TIMEEVT_PERIODIC
            #endif    //    #if (QF_MAX_TICK_RATE == 0)
            status_ = Q_HANDLED();
            break;
        }

#if (QF_MAX_TICK_RATE != 0)
        /*.${AOs::TimeBomb::SM::armed::pause::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            --me->blink_ctr;
            /*.${AOs::TimeBomb::SM::armed::pause::Q_TIMEOUT::[blink_ctr>0]} */
            if (me->blink_ctr > 0U) {
                status_ = Q_TRAN(&TimeBomb_blink);
            }
            /*.${AOs::TimeBomb::SM::armed::pause::Q_TIMEOUT::[else]} */
            else {
                status_ = Q_TRAN(&TimeBomb_boom);
            }
            break;
        }
#endif /*  (QF_MAX_TICK_RATE != 0) */

#if (QF_MAX_TICK_RATE == 0)
        /*.${AOs::TimeBomb::SM::armed::pause::TIMEOUT} */
        case TIMEOUT_SIG: {
            /*.${AOs::TimeBomb::SM::armed::pause::TIMEOUT::[te.nTicks>0]} */
            if (me->te.nTicks > 0) {
                /*.${AOs::TimeBomb::SM::armed::pause::TIMEOUT::[te.nTicks>0]::[te.nTicks)==0]} */
                if (--(me->te.nTicks) == 0) {
                    --me->blink_ctr;
                    /*.${AOs::TimeBomb::SM::armed::pause::TIMEOUT::[te.nTicks>0]::[te.nTicks)==0]::[blink_ctr>0]} */
                    if (me->blink_ctr > 0U) {
                        status_ = Q_TRAN(&TimeBomb_blink);
                    }
                    /*.${AOs::TimeBomb::SM::armed::pause::TIMEOUT::[te.nTicks>0]::[te.nTicks)==0]::[else]} */
                    else {
                        status_ = Q_TRAN(&TimeBomb_boom);
                    }
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
#endif /*  (QF_MAX_TICK_RATE == 0) */

        default: {
            status_ = Q_SUPER(&TimeBomb_armed);
            break;
        }
    }
    return status_;
}
/*.${AOs::TimeBomb::SM::armed::boom} .......................................*/
static QState TimeBomb_boom(void * me2) {
    TimeBomb *me = (TimeBomb *)me2;
    QState status_;
    switch (Q_SIG(me)) {
        /*.${AOs::TimeBomb::SM::armed::boom} */
        case Q_ENTRY_SIG: {
            BSP_ledRedOn();
            BSP_ledGreenOn();
            BSP_ledBlueOn();
            #if (defined USE_FULL_TEST)
                // Test posting a signal from outside of the ISR.
                #if (QF_MARGIN == 0)
                    #if (Q_PARAM_SIZE != 0)
                        QACTIVE_POST(AO_TimeBomb, TRIG1_SIG, 0U);
                    #else
                        QACTIVE_POST(AO_TimeBomb, TRIG1_SIG);
                    #endif  //  #if (Q_PARAM_SIZE != 0)
                #else
                    #if (Q_PARAM_SIZE != 0)
                        QACTIVE_POST_X(AO_TimeBomb, QF_MARGIN, TRIG1_SIG, 0U);
                    #else
                        QACTIVE_POST_X(AO_TimeBomb, QF_MARGIN, TRIG1_SIG);
                    #endif  //  #if (Q_PARAM_SIZE != 0)
                #endif  //  #if (QF_MARGIN == 0)
            #endif    //    #if (defined USE_FULL_TEST)
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::TimeBomb::SM::armed::boom} */
        case Q_EXIT_SIG: {
            #if (defined USE_FULL_TEST)
                #if (QF_MAX_TICK_RATE > 2)
                    QActive_disarmX(&(me->super), 2U);    // Test repeated arm/disarm.
                #endif    //    #if (QF_MAX_TICK_RATE >1)
            #endif    //    #if (defined USE_FULL_TEST)
            status_ = Q_HANDLED();
            break;
        }

#if (defined USE_FULL_TEST)
        /*.${AOs::TimeBomb::SM::armed::boom::Q_TIMEOUT1} */
        case Q_TIMEOUT1_SIG: {
            volatile uint16_t dummy = 1;
            #if ((QF_MAX_TICK_RATE > 2) && !(defined QF_TIMEEVT_PERIODIC))
                Q_ERROR();
            #endif  //  #if ((QF_MAX_TICK_RATE > 2) && (defined QF_TIMEEVT_PERIODIC))
            status_ = Q_HANDLED();
            break;
        }
#endif /*  (defined USE_FULL_TEST) */

#if (defined USE_FULL_TEST)
        /*.${AOs::TimeBomb::SM::armed::boom::Q_TIMEOUT2} */
        case Q_TIMEOUT2_SIG: {
            QActive_disarmX(&(me->super), 2U);
            QActive_armX(&(me->super), 1U, BSP_TICKS_PER_SEC, BSP_TICKS_PER_SEC);
            status_ = Q_HANDLED();
            break;
        }
#endif /*  (defined USE_FULL_TEST) */

#if (defined USE_FULL_TEST)
        /*.${AOs::TimeBomb::SM::armed::boom::TRIG1} */
        case TRIG1_SIG: {
            //  Test event timers.
            #if (QF_MAX_TICK_RATE > 1)
                #ifndef QF_TIMEEVT_PERIODIC
                    QActive_armX(&(me->super), 1U, BSP_TICKS_PER_SEC);    // Test repeated arm/disarm.
                #else
                    QActive_armX(&(me->super), 1U, BSP_TICKS_PER_SEC, 0U);    // Test repeated arm/disarm.
                #endif  //  #ifndef QF_TIMEEVT_PERIODIC
            #endif    //    #if (QF_MAX_TICK_RATE != 1)
            #if ((QF_MAX_TICK_RATE > 2) && (defined QF_TIMEEVT_PERIODIC))
                QActive_armX(&(me->super), 2U, BSP_TICKS_PER_SEC/5, BSP_TICKS_PER_SEC/5);    // Test periodic rearm.
            #endif    //    #if (QF_MAX_TICK_RATE != 0)
            status_ = Q_HANDLED();
            break;
        }
#endif /*  (defined USE_FULL_TEST) */

        default: {
            status_ = Q_SUPER(&TimeBomb_armed);
            break;
        }
    }
    return status_;
}
/*.${AOs::TimeBomb::SM::armed::wait4button} ................................*/
static QState TimeBomb_wait4button(void * me2) {
    TimeBomb *me = (TimeBomb *)me2;
    QState status_;
    switch (Q_SIG(me)) {
        /*.${AOs::TimeBomb::SM::armed::wait4button} */
        case Q_ENTRY_SIG: {
            BSP_ledGreenOn();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::TimeBomb::SM::armed::wait4button} */
        case Q_EXIT_SIG: {
            BSP_ledGreenOff();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::TimeBomb::SM::armed::wait4button::BUTTON_PRESSED} */
        case BUTTON_PRESSED_SIG: {
            me->blink_ctr = 5U;
            status_ = Q_TRAN(&TimeBomb_blink);
            break;
        }
        default: {
            status_ = Q_SUPER(&TimeBomb_armed);
            break;
        }
    }
    return status_;
}
/*.${AOs::TimeBomb::SM::defuse} ............................................*/
static QState TimeBomb_defuse(void * me2) {
    TimeBomb *me = (TimeBomb *)me2;
    QState status_;
    switch (Q_SIG(me)) {
        /*.${AOs::TimeBomb::SM::defuse} */
        case Q_ENTRY_SIG: {
            BSP_ledBlueOn();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::TimeBomb::SM::defuse} */
        case Q_EXIT_SIG: {
            BSP_ledBlueOff();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::TimeBomb::SM::defuse::BUTTON2_PRESSED} */
        case BUTTON2_PRESSED_SIG: {
            status_ = Q_TRAN(&TimeBomb_armed);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::TimeBomb} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static QEvt timeBomb_queue[TIMEBOMB_QUEUE_LEN];
static TimeBomb timeBomb;
QActive *AO_TimeBomb = &timeBomb.super;

/* QF_active[] array defines all active object control blocks ----*/
QActiveCB const Q_ROM Q_ROM_VAR QF_active[] = {
    { (QActive *)0              , (QEvt *)0             , 0                     },
    { (QActive *)&timeBomb.super, (QEvt *)timeBomb_queue, Q_DIM(timeBomb_queue) },
};

/* make sure that the QF_active[] array matches QF_MAX_ACTIVE in qpn_port.h */
Q_ASSERT_COMPILE(1U == Q_DIM(QF_active) - 1U);

/* the main function =========================================================*/
int main() {

    BSP_init(); /* initialize the BSP */
    QF_init(Q_DIM(QF_active));   /* initialize QP/C */

    /* create AO and start it */
    TimeBomb_ctor(&timeBomb);

    QF_run(); /* run QP/C... */
    return 0; /* NOTE: the scheduler does NOT return */
}

